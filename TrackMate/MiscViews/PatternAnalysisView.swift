//
//  PatternAnalysisView.swift
//  TrackMate
//
//  Created by Glen Mars on 4/8/25.
//
// Includes a weekly calendar for users to log mood, show bar charts of most frequent emotional tags, a timeline showing a trend in interactions, and a sentiment summary text that's generated by filtering the interaction for the current week and summarizing the most frequent person involved with emotion tag trend.

import SwiftUI
import Charts
import CoreData
import NaturalLanguage

private let dateFormatter: DateFormatter = {
    let formatter = DateFormatter()
    formatter.dateFormat = "EEE\ndd"
    return formatter
}()

private let weekFormatter: DateFormatter = {
    let f = DateFormatter()
    f.dateFormat = "MMM d"
    return f
}()

struct PatternAnalysisView: View {
    @Environment(\.managedObjectContext)
    private var viewContext
    
    @EnvironmentObject var themeManager: ThemeManager
    
    // Fetch all interaction records ordered by timestamp
    @FetchRequest(
        entity: Interaction.entity(),
        sortDescriptors: [NSSortDescriptor(keyPath: \Interaction.timestamp, ascending: true)]
    )
    var interactions: FetchedResults<Interaction>
    
    var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 10) {
                Text("Weekly Pattern Analysis")
                    .font(.largeTitle)
                    .bold()
                    .padding(.bottom, 5)
                    .foregroundColor(themeManager.color("PrimaryText"))
                    
                
                // Weekly Calendar with color-coded emotional states
                ScrollView(.horizontal, showsIndicators: false) {
                    HStack {
                        ForEach(getDaysForCurrentWeek(), id: \.self) { day in
                            VStack {
                                Text(day, formatter: dateFormatter)
                                    .foregroundColor(themeManager.color("SecondaryText"))
                                    .multilineTextAlignment(.center)
                                Circle()
                                    .fill(colorForDay(day: day))
                                    .frame(width: 50, height: 50)
                                    .overlay(
                                        Circle()
                                            .stroke(Color.black, lineWidth: 2)
                                    )
                            }
                        }
                    }
                    .padding(.vertical, 10)
                }
                
                // Bar chart for Most Frequent Emotion Tags
                Text("Most Frequent Emotion Tags")
                    .font(.headline)
                    .foregroundColor(themeManager.color("PrimaryText"))
                    .bold()
                    .padding(.bottom, 5)
                Chart {
                    ForEach(computeEmotionFrequencies(), id: \.key) { emotion, count in
                        BarMark(
                            x: .value("Emotion", emotion),
                            y: .value("Count", count)
                        )
                    }
                }
                .frame(height: 200)
                .foregroundColor(themeManager.color("ChartBar"))
                
                // Timeline view for interaction trend per week
                Text("Interaction Trends")
                    .font(.headline)
                    .foregroundColor(themeManager.color("PrimaryText"))
                    .bold()
                    
                
                Chart {
                    ForEach(computeWeeklyInteractionCounts(), id: \.weekStart) { dataPoint in
                        BarMark(
                            x: .value("Week", weekFormatter.string(from: dataPoint.weekStart)),
                            y: .value("Interactions", dataPoint.count)
                        )
                    }
                }
                .frame(height: 200)
                .foregroundColor(themeManager.color("ChartBar"))
                
                // Sentiment summary text
                Text(sentimentSummary())
                    .font(.body)
                    .padding()
                    .foregroundColor(themeManager.color("SecondaryText"))
            }
            .padding()
        }
        .background(themeManager.color("PrimaryBackground"))
    }
    
    // MARK: - Helper Functions
    
    // Returns the dates for the curent week (using Monday as the first day)
    func getDaysForCurrentWeek() -> [Date] {
        let calendar = Calendar.current
        let today = Date()
        var week: [Date] = []
        let weekday = calendar.component(.weekday, from: today)
        guard let startOfWeek = calendar.date(byAdding: .day, value: -(weekday - 2), to: today) else { return [] }
        for i in 0..<7 {
            if let day = calendar.date(byAdding: .day, value: i, to: startOfWeek) {
                week.append(day)
            }
        }
        return week
    }
    
    // Compute a color for a given day based on the emotional tags of that day's interactions
    func colorForDay(day: Date) -> Color {
        let dailyInteractions = interactions.filter {
            Calendar.current.isDate($0.timestamp ?? Date(), inSameDayAs: day)
        }
        let negativeEmotions = ["Sad", "Anxious", "Confused", "Belittled", "Angry", "Guilty", "Invalidated", "Unsafe"]
        let positiveEmotions = ["Happy", "Calm", "Loved", "Empowered", "Safe"]
        var score = 0
        for interaction in dailyInteractions {
            if let tags = interaction.emotionTags as? [String] {
                for tag in tags {
                    if negativeEmotions.contains(tag) {
                        score -= 1
                    } else if positiveEmotions.contains(tag) {
                        score += 1
                    }
                }
            }
        }
        if score < 0 {
            return Color("MoodNegative")
        } else if score > 0 {
            return Color("MoodPositive")
        } else {
            return .gray
        }
    }
    
    // Aggregates emotion tag frequencies from all interactions
    func computeEmotionFrequencies() -> [(key: String, value: Int)] {
        var frequency: [String: Int] = [:]
        for interaction in interactions {
            if let tags = interaction.emotionTags as? [String] {
                for tag in tags {
                    frequency[tag, default: 0] += 1
                }
            }
        }
        return frequency.sorted { $0.value > $1.value }
    }
    
    // Finds the top 3 individuals associated with negative interactions
    func computeTopNegativeIndividulas() -> [(key: String, value: Int)] {
        var negativeCount: [String: Int] = [:]
        let negativeEmotions = ["Sad", "Anxious", "Confused", "Belittled", "Angry", "Guilty", "Invalidated", "Unsafe"]
        for interaction in interactions {
            if let tags = interaction.emotionTags as? [String],
               let person = interaction.personName, !person.isEmpty,
               tags.contains(where: { negativeEmotions.contains($0) }) {
                negativeCount[person, default: 0] += 1
            }
        }
        let sorted = negativeCount.sorted { $0.value > $1.value }
        return Array(sorted.prefix(3))
    }
    
    // Data structure for timeline data points
    struct TimelineData: Identifiable {
        var id = UUID()
        var weekStart: Date
        var score: Int
    }
    
    // Aggregate weekly scores for respect/safety. Each interaction contribuets score values based on responses
    func computeSafetyRespectTimeline() -> [TimelineData] {
        let calendar = Calendar.current
        var timeline: [TimelineData] = []
        // Group interactions by week (using yearForWeekOfYear and WeekOfYear)
        let grouped = Dictionary(grouping: interactions) { (interaction) -> Date in
            let components = calendar.dateComponents([.yearForWeekOfYear, .weekOfYear], from : interaction.timestamp ?? Date())
            return calendar.date(from: components) ?? Date()
        }
        for (week, interactions) in grouped {
            var totalScore = 0
            for interaction in interactions {
                totalScore += scoreForResponse(interaction.didFeelRespected)
                totalScore += scoreForResponse(interaction.didFeelBoundariesAcknowledged)
                totalScore += scoreForResponse(interaction.didFeelEmotionallySafe)
            }
            timeline.append(TimelineData(weekStart: week, score: totalScore))
        }
        return timeline.sorted { $0.weekStart < $1.weekStart }
    }
    
    // Converts response strings to numerical scores
    func scoreForResponse(_ response: String?) -> Int {
        switch response {
        case "Yes": return 1
        case "No": return -1
        default: return 0
        }
    }
    
    // Structure to hold weekly interaction count data
    struct WeekCount: Identifiable {
        var id = UUID()
        var weekStart: Date
        var count: Int
    }
    
    // Aggregates the number of interactions per week
    func computeWeeklyInteractionCounts() -> [WeekCount] {
        let calendar = Calendar.current
        var counts: [Date: Int] = [:]
        
        for interaction in interactions {
            guard let timestamp = interaction.timestamp,
                  let startOfWeek = calendar.dateInterval(of: .weekOfYear, for: timestamp)?.start
            else { continue }
            counts[startOfWeek, default: 0] += 1
        }
        
        return counts
            .map { WeekCount(weekStart: $0.key, count: $0.value) }
            .sorted { $0.weekStart < $1.weekStart }
    }
    
    // Computes a sentiment summary string for the current week
    func sentimentSummary() -> String {
        let calendar = Calendar.current
        guard let startOfWeek = calendar.date(from: calendar.dateComponents([.yearForWeekOfYear, .weekOfYear], from: Date()))
        else {
            return "Error computing start of week."
        }
        
        let weekInteractions = interactions.filter { interaction in
            if let timestamp = interaction.timestamp {
                return timestamp >= startOfWeek
            }
            return false
        }
        
        // Total interactions for the week
        let total = weekInteractions.count
        
        // Determine which person appears most frequently this week
        let individualCount = Dictionary(grouping: weekInteractions, by: { $0.personName ?? "Unknown" })
        let topIndividual = individualCount.max { a, b in
            a.value.count < b.value.count
        }?.key ?? "Unknown"
        let topIndividualCount = individualCount[topIndividual]?.count ?? 0
        
        return "You logged \(total) interactions this week. \(topIndividualCount) involved \(topIndividual)."
            
    }
}
